<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>29. 객체</title>

    <link rel="shortcut icon" href="#">

    <script>
        function LinksSetColor(color){
            var links = document.querySelectorAll('a');
            var i = 0;
            while(i < links.length){
                links[i].style.color = color;
                i = i + 1;
            }
        }
        function BodySetColor(color){
            document.querySelector('body').style.color = color;
        }
        function BodySetBackgroundColor(color){
            document.querySelector('body').style.backgroundColor = color;
        }
        function nightDayHandler(self){
            var target = document.querySelector('body');
            if(self.value === 'night'){
                BodySetBackgroundColor('black');
                BodySetColor('white');
                self.value = 'day';

                LinksSetColor('powderblue');
            } else {
                BodySetBackgroundColor('white');
                BodySetColor('black');
                self.value = 'night';

                LinksSetColor('blue');
            }
        }
    </script>

</head>
<body>

    <h1><a href="#">WEB</a></h1>
    
    <input type="button" value="night" onclick="
        nightDayHandler(this);
    ">

    <ol>
        <li><a href="#">HTML</a></li>
        <li><a href="#">CSS</a></li>
        <li><a href="#">JavaScript</a></li>
    </ol>

    <h2>JavaScript</h2>
    <p>
        Lorem Ipsum is simply dummy text of the printing and typesetting industry."+name+" Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries,"+name+" but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing"+name+" Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.
    </p>

    <!--   
        객체(object)
        객체 : 굉장히 중요하지만 엄청 어렵다. 
        프로그래밍에서 함수와 객체가 어렵다.
        객체라는 것은 함수와 대립되는 개념이 아니라, 함수라는 기반 위에서 객체라는 것이 존재.
        
        객체의 여러면 중 하나는 정리정돈.
        프로그래밍을 하다보면 코드가 많아지고, 코드를 잘 정리정돈 하기 위해서 함수라는 것을 사용하는데,
        함수라는것이 또 많아지면, 함수 뿐만 아니라 함수와 연관되어 있는 변수들이, 엄청나게 많아지면,
        복잡도의 한계에 도달하게 된다. 
        이런 한계상황에서 서로 연관된 함수와, 연관된 변수를 같은 이름으로 그룹핑해서 잘 정리정돈을 하기 위한 도구.
        => 객체(object)

        함수 중에서 중복되는 것이 보인다. 
        var links = document.querySelectorAll('a');
                var i = 0;
                while(i < links.length){
                    links[i].style.color = 'powderblue';
                    i = i + 1;
                }

        var links = document.querySelectorAll('a');
                var i = 0;
                while(i < links.length){
                    links[i].style.color = 'blue';
                    i = i + 1;
                }

        중복된 코드을 만나게 되면 함수로 독립을 시킬 수 있다. 
        function setColor(color){
            var links = document.querySelectorAll('a');
            var i = 0;
            while(i < links.length){
                links[i].style.color = color;
                i = i + 1;
            }
        }
        setColor라는 함수를 만들고 매개 변수를 color라고 세팅을 해주고, 중복되었던 코드를 복사해 붙여넣어준다. 
        그리고 powderblue라고 지정되어 있던 것을 매개 변수인 color로 지정을 하게 되면,
        매개 변수를 통해서 값이 바뀔 수 있게 된다. 
        function setColor(color){
            var links = document.querySelectorAll('a');
            var i = 0;
            while(i < links.length){
                links[i].style.color = color;
                i = i + 1;
            }
        }
        function nightDayHandler(self){
            var target = document.querySelector('body');
            if(self.value === 'night'){
                target.style.backgroundColor = 'black';
                target.style.color = 'white';
                self.value = 'day'

                setColor('powderblue');
            } else {
                target.style.backgroundColor = 'white';
                target.style.color = 'black';
                self.value = 'night'

                setColor('blue');
            }
        }
        중복되었던 코드 자리에 setColor라는 함수를 넣어주고 인자('powderblue', 'blue')에 값을 넣어주면 매개 변수(color)를 통해서 입력이 되고 잘 동작하는 것을 볼 수가 있다. 

        target.style.color = 'white';
        => 코드를 보면 웹페이지에 있는 body태그에 글자색을 흰색으로 한다는 뜻이다. 
            한 줄 밖에 되지 않기 때문에 함수화 시키는 것은 의미가 없을 수도 있겠지만, 비교적 의미가 명확하지만, 
            한줄이라고 하더라도 그 의미가 불명확하거나, 시간이 지나면 무슨 뜻이었는지 파악하기 어려울 때에는, 
            함수를 통해서 그 로직의 이름을 부여하는 것도 좋은 전략이 될 수 있다. 
        function setColor(color){
            target.style.color = color;
        }
        => 다시 setColor라는 함수를 만들어주면 어떻게 되는지 보면, 기존의 setColor라는 함수가 있는데 중복되게 만들면,
            기존의 것은 다음에 나오는 함수에 의해서 덮어쓰게 되면서 삭제가 되는 결과를 갖게 된다. 
            만약 코드가 굉장히 복잡하고 많을 경우, 이런 경우에 setColor라는 함수가 기존에 있었는지 없었는지 생각하기가 쉬울까?
            어려울 것이다. 
            이름이 중복되면서 다른 코드가 동작 하게 되면 얼마나 심각한 일을 초래할 수 있을지에 대해서 상상해보면 끔찍하다. 
            이름이 충돌이 되지 않도록 좀 더 구체적으로 지어줘야 한다. 
            LinksSetColor , BodySetColor
        function BodySetColor(color){
            target.style.color = color;
        }
        => 코드가 오류가 난다. 글자색이 바뀌지가 않는다.
            왜냐하면 target이라는 변수는 nightDayHandler라는 함수 안에서 설정된 값이기 때문에,
            BodySetColor에서의 target이라는 변수는 먹히질 않는다. 
            따라서, 선택자를 다시 설정해 줘야 한다. 
            => function BodySetColor(color){
                    document.querySelector('body').style.color = color;
                }
                => BodySetColor('white')
        
        마찬가지로, 배경색도 함수를 만들어 줄 수 있다. 
        target.style.backgroundColor = 'white';
        => function BodySetBackgroundColor(color){
                document.querySelector('body').style.backgroundColor = color;
            }
            => BodySetBackgroundColor('white');
        
        이렇게 함수를 만들어서 코드에 함수로 대체해도 정확히 똑같이 동작하는 것을 볼 수 있다. 
        이런식의 방법도 있지만, 이런 경우에 사용을 하게 하기 위해 객체(object)라는 것을 만들었다.
        즉, 서로 연관된 함수와, 연관된 변수들을 그룹핑해서 정리정돈 하기 위한 수납상자로서 객체라는 것이 존재한다. 

        객체를 만들게 되면. (Body라는 객체, links라는 객체)
        =>
        function nightDayHandler(self){
            var target = document.querySelector('body');
            if(self.value === 'night'){
                Body.setBackgroundColor('black');
                Body.setColor('white');
                self.value = 'day';

                Links.setColor('powderblue');
            } else {
                Body.setBackgroundColor('white');
                Body.setColor('black');
                self.value = 'night';

                Links.setColor('blue');
            }
        BodySetBackgroundColor() -> Body.setBackgroundColor()
        이런 식으로 보여지게 된다. 
        이름 자체를 길게 나열하는 것 보다는 폴더를 만들어서 정리정돈을 할 수 있도록 하는 것.
        객체라고 하는 것을 폴더라는 관점으로 봐도 무방하다. 
        
        document.querySelector('body').style.backgroundColor = color;
        => document라고 되어있는 것이 객체라는 것을 알 수 있다. 
            그리고 document. 뒤에 있는 querySelector()라는 것이 형태를 보니까 document라는 객체에 속해있는 함수라는 것을 알 수 있다. 
            그리고 객체에 속해있는 함수는 함수라고 하지 않고 메서드(method)라고 부른다. 

        function nightDayHandler(self){
            var target = document.querySelector('body');
            if(self.value === 'night'){
                Body.setBackgroundColor('black');
                Body.setColor('white');
                self.value = 'day';

                Links.setColor('powderblue');
            } else {
                Body.setBackgroundColor('white');
                Body.setColor('black');
                self.value = 'night';

                Links.setColor('blue');
            }
        => 현재 이 코드는 동작하지 않는 상태. 
            객체를 만들어야 하는데 만들지를 않았기 때문. 

    -->

</body>
</html>